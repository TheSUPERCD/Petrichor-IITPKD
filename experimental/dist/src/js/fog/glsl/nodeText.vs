__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute vec3 position3;\nattribute vec3 position4;\nattribute vec3 position5;\nattribute vec2 uv;\nattribute float opacity;\nattribute float opacity2;\nattribute float opacity3;\nattribute float opacity4;\nattribute float opacity5;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex))\n    + position3 * step(2.0, prevIndex) * (1.0 - step(3.0, prevIndex))\n    + position4 * step(3.0, prevIndex) * (1.0 - step(4.0, prevIndex))\n    + position5 * step(4.0, prevIndex) * (1.0 - step(5.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex))\n    + position3 * step(2.0, nextIndex) * (1.0 - step(3.0, nextIndex))\n    + position4 * step(3.0, nextIndex) * (1.0 - step(4.0, nextIndex))\n    + position5 * step(4.0, nextIndex) * (1.0 - step(5.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex))\n    + opacity3 * step(2.0, prevIndex) * (1.0 - step(3.0, prevIndex))\n    + opacity4 * step(3.0, prevIndex) * (1.0 - step(4.0, prevIndex))\n    + opacity5 * step(4.0, prevIndex) * (1.0 - step(5.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex))\n    + opacity3 * step(2.0, nextIndex) * (1.0 - step(3.0, nextIndex))\n    + opacity4 * step(3.0, nextIndex) * (1.0 - step(4.0, nextIndex))\n    + opacity5 * step(4.0, nextIndex) * (1.0 - step(5.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition, 1.0);\n\n  vPosition = mixPosition;\n  vUv = uv;\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n");
